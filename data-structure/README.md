# Data structure (자료구조)

## 정렬 및 탐색
### [selection sort (선택 정렬)](https://github.com/euichanhwang/CS_study/blob/main/data-structure/%EC%A0%95%EB%A0%AC%20%EB%B0%8F%20%ED%83%90%EC%83%89/SelectionSort.cpp)  
**정렬되지 않은 정수들 중에서 가장 작은 값을 찾아서 정렬된 리스트 다음 자리에 놓는 정렬방법.**  
`1 10 5 8 7 6 4 3 2 9` 라는 정렬되지 않은 정수에서 가장 작은 값을 찾으면 1이다. 가장 앞으로 보낸다.  
1은 이미 가장 앞에 있으므로 정렬이 이루어졌다. 가장 앞의 1을 제외하고 가장 작은 값은 2인데, 1을 제외  
하고 가장 앞에 있는 원소 10과 바꾸면 `1 2 5 8 7 6 4 3 10 9`가 된다. 이후에 세번째로 가장 작은 값은 3  
인데 이 값을 5와 바꾸면 `1 2 3 8 7 6 4 5 10 9` 가 된다. 이러한 과정을 반복하면 끝까지 반복했을 때  
`1 2 3 4 5 6 7 8 9 10` 이라는 정렬된 정수 리스트를 얻을 수 있다.  
```c++
 for(int j=i;j<n;j++)
        {
            if(min>list[j])
            {
                min=list[j];
                index=j;
            }
        } // 가장 작은 원소를 찾아서 위치를 저장한다
temp=list[i];
        list[i]=list[index];
        list[index]=temp; // 두 원소의 위치를 바꾼다
```    
**💡선택 정렬의 시간 복잡도 : N(N+1)/2 => O(N^2)**   
### [bubble sort (버블 정렬)](https://github.com/euichanhwang/CS_study/blob/main/data-structure/%EC%A0%95%EB%A0%AC%20%EB%B0%8F%20%ED%83%90%EC%83%89/BubbleSort.cpp)
**옆에 있는 값과 비교해서 더 작은 값을 앞으로 보내는 정렬방법**  
`1 10 5 8 7 6 4 3 2 9` 라는 정렬되지 않은 정수에서 먼저 1과 10을 비교해서 더 작은 것을 앞으로 옮긴다.  
이미 1이 앞에 있으므로 그 다음 10과 5를 비교해서 더 작은 5를 앞으로 보내면 `1 5 10 8 7 6 4 3 2 9`이다.  
다음으로 10과 8을 비교해서 더 작은것을 앞으로 옮기면 `1 5 8 10 7 6 4 3 2 9` 이다. 그 다음으로 7과 10을  
비교해서 더 작은 7을 앞으로 옮기면 `1 5 8 7 10 6 4 3 2 9`이다. 이런식으로 한번의 반복이 끝났을때 리스트는  
`1 5 8 7 6 4 3 2 9 10` 인데, 가장 큰 값이 맨 뒤로 보내지는 방식이다. 10을 제외하고 1부터 9까지 앞의 방법  
을 이용해서 반복하면, 수행했을 때 결과는 가장 큰값이었던 9가 맨 뒤로 보내진 리스트를 얻게 된다. 끝까지   
반복하면  `1 2 3 4 5 6 7 8 9 10` 이라는 정렬된 리스트를 얻을 수 있다.  
```c++
for(j=0;j<9-i;j++) //뒤에서부터 집합의 크기 하나씩 감소
        {
            if(array[j]>array[j+1])
            {
                temp=array[j];
                array[j]=array[j+1];
                array[j+1]=temp;
            }
        }
```  
**💡버블 정렬의 시간 복잡도 : O(N^2)** 시간 복잡도는 선택 정렬과 동일하나 실제 수행 시간으로는 선택 정렬보다 훨씬  
느리다. 매번 교체를 해줘야 하는 점에서 실제로 더욱 비효율적이다.
### [insertion sort (삽입 정렬)](https://github.com/euichanhwang/CS_study/blob/main/data-structure/%EC%A0%95%EB%A0%AC%20%EB%B0%8F%20%ED%83%90%EC%83%89/InsertionSort.cpp)  
**각 숫자를 적절한 위치에 삽입하는 정렬방법**  
다른 정렬 방식들과 달리 삽입 정렬은 '필요할 때만' 위치를 바꾼다. `1 10 5 8 7 6 4 3 2 9` 라는 리스트에서, 1은 이미  
가장 앞에있어 삽입할 위치가 없어 내버려둔다. 10을 살펴보면, 10은 1의 앞과 뒤에 올 수 있는데,_ 1 _ 1보다 크므로 뒤  
쪽에 위치한다. 5는 앞을 봤을 때 들어갈 위치가 _ 1 _ 10 _ 이렇게 세 자리가 있는데, 가운데 위치에 들어간다. _ 1 5 10 _  
8은 _ 1 _ 5 _ 10 _ 중, 5와 10 사이에 들어가므로, 1 5 8 10 이렇게 정렬된 리스트가 반환된다. 이런 식으로 반복하면,  
정렬된 리스트를 얻을 수 있다. 앞의 원소들이 이미 정렬되어 있기 때문에 위치를 서로 바꿔주기만 하면 되므로 전체를  
다 살펴볼 필요가 없다. 
```c++
while(array[j]>array[j+1])
         {
             temp=array[j];
             array[j]=array[j+1];
             array[j+1]=temp;
             /* 옆에있는것과 비교, 하나씩 내려가면서 
             옆 원소가 더 크다면 바꿔준다*/
             j--; 
             if(j<0)
                break; 
         }
```  
**💡삽입 정렬의 시간 복잡도 : O(N^2)** 필요할 때만 삽입을 진행하므로 데이터가 정렬된 상태에서는 어떤 알고리즘보다 빠르다는  
특징을 가진다.  
### [quick sort (퀵정렬)]()
**대표적인 '분할 정복'알고리즘을 활용한 정렬방법**  
특정한 값(기준값=Pivot) 기준으로 큰 숫자와 작은 숫자의 집합으로 나누는 방법. 보통 첫번째 원소를 피벗으로 지정한다.  
`(3) 7 8 1 5 9 6 10 2 4` 라는 리스트에서 첫번째 원소 3을 피벗으로 지정한다. 왼쪽에서 오른쪽으로 이동하며 검사를 할 때는,  
3보다 큰 값을 선택한다. 따라서 7을 선택한다. 오른쪽에서 왼쪽으로 검사할 때는 3보다 작은 값을 선택한다. 따라서 2를 선택한다.  
그 이후에 큰 값과 작은 값을 서로 바꾸어준다. `(3) 2 8 1 5 9 6 10 7 4` 이 상황에서 이전처럼 3보다 큰 값인 8을 선택하고,  
작은 값인 1을 선택해서 위치를 바꾸어준다. `(3) 2 1 8 5 9 6 10 7 4` 마찬가지로 pivot을 고정한 채 큰 값 8과 작은 값 1이  
구해지는데 8과 1은 서로 **엇갈린다.즉, 작은 값의 인덱스가 큰 값의 인덱스보다 더 작다.** 이런 상황에서는 왼쪽에 있는 값  
과 3을 서로 바꿔준다. `1 2 (3) 8 5 9 6 10 7 4` 이런식으로 하면 3왼쪽은 3보다 작은 값들이, 3 오른쪽에는 3보다 큰 값  
이 위치해서 `1 2`라는 기준값 3보다 작은 리스트와 `8 5 9 6 10 7 4` 기준값 3보다 큰 리스트로 분할된 것을 알 수 있다.  
3보다 작은 리스트에서는 1을 기준값으로 해서, `(1) 2` 3보다 큰 리스트에서는 8을 기준값으로 해서 `(8) 5 9 6 10 7 4`  
또 정렬을 수행한다. 이런식으로 퀵 정렬을 반복하면, `1 2 3 4 5 6 7 8 9 10` 이라는 정렬된 리스트를 얻을 수 있다.  

### [binary search (이진 탐색)](https://github.com/euichanhwang/CS_study/blob/main/data-structure/%EC%A0%95%EB%A0%AC%20%EB%B0%8F%20%ED%83%90%EC%83%89/BinarySearch.cpp)

---

**💡퀵 정렬의 시간 복잡도 : O(N*logN)**  
`1 2 3 4 5 6 7 8 9 10`을 정렬한다고 하면, 원소의 수가 10개일 때 선택 정렬을 이용하면 10 \times 10=100 이지만 퀵 정렬은 분할 정렬이므로     
`1 2 3 4 5` 와 `6 7 8 9 10`으로 분할한 뒤 5 \times 5=25 연산을 2번 수행하므로 훨씬 빠르다.   

## class 배열
